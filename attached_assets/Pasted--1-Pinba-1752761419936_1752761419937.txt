// АЛЬТЕРНАТИВНЫЙ ПОДХОД: вернуться к одинарной проверке, но улучшить саму коллизию

// 1. В PinballGame.js УБРАТЬ двойную проверку:
checkCollisions() {
    // ===== ВЕРНУТЬСЯ К ПРОСТОМУ =====
    this.currentLevel.walls.forEach(wall => {
        wall.checkCollision(this.ball);
    });
    // ===== БЕЗ ЦИКЛОВ! =====

    // Остальные коллизии...
    this.currentLevel.flippers.forEach(flipper => {
        flipper.checkCollision(this.ball);
    });
    // ... и так далее
}

// 2. В Wall.js УЛУЧШИТЬ checkLineCollision:
checkLineCollision(ball) {
    // Убираем защиту от повторных коллизий (она нам больше не нужна)
    // Убираем блок:
    // if (!this.lastCollisionFrame) this.lastCollisionFrame = 0;
    // const currentFrame = performance.now();
    // if (currentFrame - this.lastCollisionFrame < 20) {
    //     return false;
    // }
    
    // Обычная проверка текущей позиции
    const distance = distanceToLineSegment(ball.position, new Vector2D(this.x1, this.y1), new Vector2D(this.x2, this.y2));

    if (distance < ball.radius + this.width / 2) {
        const normal = getNormalToLineSegment(ball.position, new Vector2D(this.x1, this.y1), new Vector2D(this.x2, this.y2));

        // ===== УЛУЧШЕНИЯ ДЛЯ УГЛОВ =====
        
        // 1. Более агрессивное отталкивание
        const overlap = ball.radius + this.width / 2 - distance;
        const pushDistance = overlap + 3; // Было overlap * 0.8, стало overlap + 3
        ball.position.x += normal.x * pushDistance;
        ball.position.y += normal.y * pushDistance;

        // 2. Проверяем, не слишком ли близко к концам стены (углы)
        const ballToStart = Math.sqrt(
            Math.pow(ball.position.x - this.x1, 2) + 
            Math.pow(ball.position.y - this.y1, 2)
        );
        const ballToEnd = Math.sqrt(
            Math.pow(ball.position.x - this.x2, 2) + 
            Math.pow(ball.position.y - this.y2, 2)
        );
        const wallLength = Math.sqrt(
            Math.pow(this.x2 - this.x1, 2) + 
            Math.pow(this.y2 - this.y1, 2)
        );
        
        const cornerThreshold = ball.radius * 2; // Радиус "опасной зоны" угла
        const isNearCorner = ballToStart < cornerThreshold || ballToEnd < cornerThreshold;
        
        if (isNearCorner) {
            // Для углов: более сильное отталкивание + дополнительный импульс
            ball.position.x += normal.x * 5; // Дополнительный отступ
            ball.position.y += normal.y * 5;
            
            // Более сильный отскок для углов
            const dotProduct = ball.velocity.dot(normal);
            ball.velocity.x -= 2.5 * dotProduct * normal.x; // Было 2, стало 2.5
            ball.velocity.y -= 2.5 * dotProduct * normal.y;
            ball.velocity.multiply(CONFIG.BOUNCE_DAMPING * 1.1); // Меньше затухание
        } else {
            // Обычное отражение для середины стены
            const dotProduct = ball.velocity.dot(normal);
            ball.velocity.x -= 2 * dotProduct * normal.x;
            ball.velocity.y -= 2 * dotProduct * normal.y;
            ball.velocity.multiply(CONFIG.BOUNCE_DAMPING);
        }
        
        // ===== КОНЕЦ УЛУЧШЕНИЙ =====

        return true;
    }

    // Anti-tunneling остается как есть
    if (ball.lastPosition && ball.velocity.magnitude() > ball.radius * 0.5) {
        return this.sweepTestLine(ball);
    }

    return false;
}

// 3. ДОПОЛНИТЕЛЬНО: увеличить толщину стен в CONFIG
const CONFIG = {
    // ... остальные настройки
    
    // WALL_WIDTH: 20,  // БЫЛО
    WALL_WIDTH: 22,     // СТАЛО - чуть толще стены
    
    // Можно поэкспериментировать с этими значениями:
    WALL_CORNER_SAFETY: 2.5,  // Множитель силы отскока для углов
    WALL_PUSH_DISTANCE: 3     // Дополнительное расстояние отталкивания
};