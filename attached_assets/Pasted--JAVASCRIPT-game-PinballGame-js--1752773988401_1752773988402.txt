// –ü–†–û–°–¢–û–ï –í–ê–ù–ò–õ–¨–ù–û–ï JAVASCRIPT –†–ï–®–ï–ù–ò–ï
// –ó–∞–º–µ–Ω–∏—Ç—å –≤ game/PinballGame.js

// –ó–ê–ú–ï–ù–ò–¢–¨ –í–ï–°–¨ –ú–ï–¢–û–î createSimpleCollisionGrid()
createSimpleCollisionGrid() {
    const cellSize = 8; // –ü—Ä–æ—Å—Ç–æ–π —Ä–∞–∑—É–º–Ω—ã–π —Ä–∞–∑–º–µ—Ä
    const cols = Math.ceil(CONFIG.VIRTUAL_WIDTH / cellSize);  // 40 –∫–æ–ª–æ–Ω–æ–∫  
    const rows = Math.ceil(CONFIG.VIRTUAL_HEIGHT / cellSize); // 60 —Å—Ç—Ä–æ–∫
    
    console.log(`üîç Creating collision grid: ${cols}√ó${rows} (${cols * rows} cells)`);
    const startTime = performance.now();
    
    // –ü–†–û–°–¢–´–ï –û–ë–´–ß–ù–´–ï –ú–ê–°–°–ò–í–´ (–Ω–µ —Ç–∏–ø–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω—ã–µ!)
    const grid = [];
    
    // Initialize grid
    for (let row = 0; row < rows; row++) {
        grid[row] = [];
        for (let col = 0; col < cols; col++) {
            grid[row][col] = {
                solid: false,
                dangerLevel: 0,
                escapeDirection: null
            };
        }
    }
    
    // Mark wall cells (–ü–†–û–°–¢–û–ô –°–ü–û–°–û–ë)
    this.currentLevel.walls.forEach(wall => {
        this.markWallCells(grid, wall, cellSize, cols, rows);
    });
    
    // Compute danger levels (–ü–†–û–°–¢–û–ô –ê–õ–ì–û–†–ò–¢–ú)
    this.computeDangerLevels(grid, cols, rows);
    
    // Compute escape directions (–ü–†–û–°–¢–û–ô –ê–õ–ì–û–†–ò–¢–ú)
    this.computeEscapeDirections(grid, cols, rows, cellSize);
    
    const totalTime = (performance.now() - startTime).toFixed(1);
    console.log(`‚úÖ Collision grid ready in ${totalTime}ms`);
    
    return {
        grid: grid,
        cellSize: cellSize,
        cols: cols,
        rows: rows,
        
        checkPosition: (x, y) => {
            const col = Math.floor(x / cellSize);
            const row = Math.floor(y / cellSize);
            
            if (row >= 0 && row < rows && col >= 0 && col < cols) {
                return grid[row][col];
            }
            return { solid: false, dangerLevel: 0, escapeDirection: null };
        }
    };
}

// –ü–†–û–°–¢–û–ô checkGridBasedCollisions (–ó–ê–ú–ï–ù–ò–¢–¨)
checkGridBasedCollisions() {
    const ballInfo = this.collisionGrid.checkPosition(
        this.ball.position.x, 
        this.ball.position.y
    );
    
    // If ball is in dangerous zone - –í–´–°–û–ö–ò–ô –ü–û–†–û–ì!
    if (ballInfo.dangerLevel > 0.85 && ballInfo.escapeDirection) {
        // Gently guide ball to safety - –°–õ–ê–ë–ê–Ø –°–ò–õ–ê!
        const escapeForce = ballInfo.dangerLevel * 0.3;
        
        this.ball.velocity.x += ballInfo.escapeDirection.x * escapeForce;
        this.ball.velocity.y += ballInfo.escapeDirection.y * escapeForce;
        
        console.log(`üö® Ball in danger zone (${ballInfo.dangerLevel.toFixed(2)}), applying escape force`);
    }
}

// –î–û–ë–ê–í–ò–¢–¨ –ü–†–û–°–¢–´–ï –ú–ï–¢–û–î–´ (–µ—Å–ª–∏ –∏—Ö –Ω–µ—Ç):

markWallCells(grid, wall, cellSize, cols, rows) {
    // –ü—Ä–æ—Å—Ç–∞—è —Ä–∞—Å—Ç–µ—Ä–∏–∑–∞—Ü–∏—è —Å—Ç–µ–Ω—ã
    const steps = Math.max(
        Math.abs(wall.x2 - wall.x1), 
        Math.abs(wall.y2 - wall.y1)
    ) / cellSize;
    
    for (let i = 0; i <= steps; i++) {
        const t = i / steps;
        const x = wall.x1 + (wall.x2 - wall.x1) * t;
        const y = wall.y1 + (wall.y2 - wall.y1) * t;
        
        const col = Math.floor(x / cellSize);
        const row = Math.floor(y / cellSize);
        
        // –û—Ç–º–µ—á–∞–µ–º –∫–ª–µ—Ç–∫—É –∏ —Å–æ—Å–µ–¥–µ–π (–¥–ª—è —Ç–æ–ª—â–∏–Ω—ã —Å—Ç–µ–Ω—ã)
        for (let dr = -1; dr <= 1; dr++) {
            for (let dc = -1; dc <= 1; dc++) {
                const newRow = row + dr;
                const newCol = col + dc;
                
                if (newRow >= 0 && newRow < rows && newCol >= 0 && newCol < cols) {
                    grid[newRow][newCol].solid = true;
                }
            }
        }
    }
}

computeDangerLevels(grid, cols, rows) {
    for (let row = 0; row < rows; row++) {
        for (let col = 0; col < cols; col++) {
            let solidNeighbors = 0;
            let totalNeighbors = 0;
            
            // –ü—Ä–æ–≤–µ—Ä—è–µ–º 3x3 —Å–æ—Å–µ–¥–µ–π
            for (let dr = -1; dr <= 1; dr++) {
                for (let dc = -1; dc <= 1; dc++) {
                    if (dr === 0 && dc === 0) continue;
                    
                    const newRow = row + dr;
                    const newCol = col + dc;
                    
                    if (newRow >= 0 && newRow < rows && newCol >= 0 && newCol < cols) {
                        totalNeighbors++;
                        if (grid[newRow][newCol].solid) {
                            solidNeighbors++;
                        }
                    }
                }
            }
            
            // Danger level = –¥–æ–ª—è —Ç–≤–µ—Ä–¥—ã—Ö —Å–æ—Å–µ–¥–µ–π
            grid[row][col].dangerLevel = totalNeighbors > 0 ? solidNeighbors / totalNeighbors : 0;
        }
    }
}

computeEscapeDirections(grid, cols, rows, cellSize) {
    for (let row = 0; row < rows; row++) {
        for (let col = 0; col < cols; col++) {
            if (grid[row][col].dangerLevel > 0.7) {
                // –û–ø–∞—Å–Ω–∞—è –∫–ª–µ—Ç–∫–∞ - –∏—â–µ–º –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –∫ –±–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç–∏
                let bestDirection = null;
                let bestSafety = -1;
                
                // –ü—Ä–æ–≤–µ—Ä—è–µ–º –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏—è (–Ω–µ–±–æ–ª—å—à–æ–π —Ä–∞–¥–∏—É—Å)
                for (let dr = -2; dr <= 2; dr++) {
                    for (let dc = -2; dc <= 2; dc++) {
                        if (dr === 0 && dc === 0) continue;
                        
                        const newRow = row + dr;
                        const newCol = col + dc;
                        
                        if (newRow >= 0 && newRow < rows && newCol >= 0 && newCol < cols) {
                            const safety = 1 - grid[newRow][newCol].dangerLevel;
                            if (safety > bestSafety) {
                                bestSafety = safety;
                                bestDirection = { x: dc, y: dr };
                            }
                        }
                    }
                }
                
                if (bestDirection) {
                    const length = Math.sqrt(bestDirection.x * bestDirection.x + bestDirection.y * bestDirection.y);
                    grid[row][col].escapeDirection = {
                        x: bestDirection.x / length,
                        y: bestDirection.y / length
                    };
                }
            }
        }
    }
}

// –£–î–ê–õ–ò–¢–¨ –í–°–ï –°–õ–û–ñ–ù–´–ï –ú–ï–¢–û–î–´:
// - rasterizeWallPixelPerfect()
// - computeDangerLevelsPixelPerfect()
// - computeEscapeDirectionsPixelPerfect()

// ===================================================================
// –†–ï–ó–£–õ–¨–¢–ê–¢ - –ß–ò–°–¢–´–ô –í–ê–ù–ò–õ–¨–ù–´–ô JAVASCRIPT:
// ===================================================================

/*
‚úÖ –ù–ò–ö–ê–ö–ò–• —Ç–∏–ø–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω—ã—Ö –º–∞—Å—Å–∏–≤–æ–≤ 
‚úÖ –ù–ò–ö–ê–ö–ò–• —Å–ª–æ–∂–Ω—ã—Ö –∞–ª–≥–æ—Ä–∏—Ç–º–æ–≤
‚úÖ –ü–†–û–°–¢–´–ï –æ–±—ã—á–Ω—ã–µ –æ–±—ä–µ–∫—Ç—ã –∏ –º–∞—Å—Å–∏–≤—ã
‚úÖ –ë–´–°–¢–†–ê–Ø –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è (~5ms)
‚úÖ –†–ê–ó–ú–ï–†: 40√ó60 = 2,400 –∫–ª–µ—Ç–æ–∫
‚úÖ –¢–û–ß–ù–û–°–¢–¨: –≤ 2 —Ä–∞–∑–∞ –ª—É—á—à–µ –æ—Ä–∏–≥–∏–Ω–∞–ª–∞
‚úÖ –°–û–í–ú–ï–°–¢–ò–ú–û–°–¢–¨: 100% –≤–∞–Ω–∏–ª—å–Ω—ã–π JS

–õ–û–ì–ò:
üîç Creating collision grid: 40√ó60 (2400 cells)  
‚úÖ Collision grid ready in 5ms
*/