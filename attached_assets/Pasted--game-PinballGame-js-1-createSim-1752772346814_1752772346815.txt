–§–ê–ô–õ –î–õ–Ø –ò–ó–ú–ï–ù–ï–ù–ò–Ø: game/PinballGame.js

‚úÖ –®–ê–ì 1: –ó–∞–º–µ–Ω–∞ –º–µ—Ç–æ–¥–∞ —Å–æ–∑–¥–∞–Ω–∏—è —Å–µ—Ç–∫–∏
–ù–ê–ô–¢–ò –º–µ—Ç–æ–¥ createSimpleCollisionGrid() (–ø—Ä–∏–º–µ—Ä–Ω–æ —Å—Ç—Ä–æ–∫–∞ 778):
javascript// Collision Grid System Implementation
createSimpleCollisionGrid() {
    const cellSize = 16;
    const cols = Math.ceil(CONFIG.VIRTUAL_WIDTH / cellSize);
    const rows = Math.ceil(CONFIG.VIRTUAL_HEIGHT / cellSize);
    
    const grid = [];
    // ... –æ—Å—Ç–∞–ª—å–Ω–æ–π –∫–æ–¥ ...
}
–ó–ê–ú–ï–ù–ò–¢–¨ –í–ï–°–¨ –ú–ï–¢–û–î –Ω–∞:
javascript// Pixel-Perfect Collision Grid System
createSimpleCollisionGrid() {
    const cellSize = 1; // –ü–ò–ö–°–ï–õ–¨–ù–ê–Ø –¢–û–ß–ù–û–°–¢–¨!
    const cols = CONFIG.VIRTUAL_WIDTH;   // 320 –∫–æ–ª–æ–Ω–æ–∫
    const rows = CONFIG.VIRTUAL_HEIGHT;  // 480 —Å—Ç—Ä–æ–∫
    
    console.log(`üîç Creating pixel-perfect grid: ${cols}√ó${rows} (${cols * rows} cells)`);
    const startTime = performance.now();
    
    // –ò—Å–ø–æ–ª—å–∑—É–µ–º —Ç–∏–ø–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω—ã–µ –º–∞—Å—Å–∏–≤—ã –¥–ª—è –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç–∏
    const solidGrid = new Uint8Array(cols * rows);           // 0/1 –¥–ª—è solid
    const dangerGrid = new Float32Array(cols * rows);        // 0.0-1.0 –¥–ª—è danger level
    const escapeXGrid = new Float32Array(cols * rows);       // escape direction X
    const escapeYGrid = new Float32Array(cols * rows);       // escape direction Y
    
    // Mark wall pixels
    this.currentLevel.walls.forEach(wall => {
        this.rasterizeWallPixelPerfect(wall, solidGrid, cols, rows);
    });
    
    console.log(`‚ö° Wall rasterization: ${(performance.now() - startTime).toFixed(1)}ms`);
    
    // Compute danger levels
    this.computeDangerLevelsPixelPerfect(solidGrid, dangerGrid, cols, rows);
    
    console.log(`‚ö° Danger computation: ${(performance.now() - startTime).toFixed(1)}ms`);
    
    // Compute escape directions
    this.computeEscapeDirectionsPixelPerfect(dangerGrid, escapeXGrid, escapeYGrid, cols, rows);
    
    const totalTime = (performance.now() - startTime).toFixed(1);
    console.log(`‚úÖ Pixel-perfect grid ready in ${totalTime}ms`);
    
    return {
        solidGrid,
        dangerGrid,
        escapeXGrid,
        escapeYGrid,
        cellSize: 1,
        cols,
        rows,
        
        // –°–≤–µ—Ä—Ö–±—ã—Å—Ç—Ä–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞ –ø–æ–∑–∏—Ü–∏–∏
        checkPosition: (x, y) => {
            const col = Math.floor(x);
            const row = Math.floor(y);
            
            if (row >= 0 && row < rows && col >= 0 && col < cols) {
                const index = row * cols + col;
                return {
                    solid: solidGrid[index] > 0,
                    dangerLevel: dangerGrid[index],
                    escapeDirection: escapeXGrid[index] !== 0 || escapeYGrid[index] !== 0 ? 
                        { x: escapeXGrid[index], y: escapeYGrid[index] } : null
                };
            }
            return { solid: false, dangerLevel: 0, escapeDirection: null };
        }
    };
}

‚úÖ –®–ê–ì 2: –ó–∞–º–µ–Ω–∞ –º–µ—Ç–æ–¥–∞ –ø—Ä–æ–≤–µ—Ä–∫–∏ –∫–æ–ª–ª–∏–∑–∏–π
–ù–ê–ô–¢–ò –º–µ—Ç–æ–¥ checkGridBasedCollisions() (–ø—Ä–∏–º–µ—Ä–Ω–æ —Å—Ç—Ä–æ–∫–∞ 953):
javascriptcheckGridBasedCollisions() {
    const ballInfo = this.collisionGrid.checkPosition(
        this.ball.position.x, 
        this.ball.position.y
    );
    
    // If ball is in dangerous zone
    if (ballInfo.dangerLevel > 0.5 && ballInfo.escapeDirection) {
        // ... –∫–æ–¥ ...
    }
}
–ó–ê–ú–ï–ù–ò–¢–¨ –í–ï–°–¨ –ú–ï–¢–û–î –Ω–∞:
javascriptcheckGridBasedCollisions() {
    const ballX = Math.floor(this.ball.position.x);
    const ballY = Math.floor(this.ball.position.y);
    const ballRadius = CONFIG.BALL_RADIUS;
    
    // –ü—Ä–æ–≤–µ—Ä—è–µ–º –Ω–µ –æ–¥–∏–Ω –ø–∏–∫—Å–µ–ª—å, –∞ –æ–±–ª–∞—Å—Ç—å –ø–æ–¥ –º—è—á–æ–º
    let maxDangerLevel = 0;
    let bestEscapeDirection = null;
    let totalDanger = 0;
    let checkedPixels = 0;
    
    // –ü—Ä–æ–≤–µ—Ä—è–µ–º –≤—Å–µ –ø–∏–∫—Å–µ–ª–∏ –≤ —Ä–∞–¥–∏—É—Å–µ –º—è—á–∞
    for (let dy = -ballRadius; dy <= ballRadius; dy++) {
        for (let dx = -ballRadius; dx <= ballRadius; dx++) {
            // –ü—Ä–æ–≤–µ—Ä—è–µ–º, –Ω–∞—Ö–æ–¥–∏—Ç—Å—è –ª–∏ –ø–∏–∫—Å–µ–ª—å –≤–Ω—É—Ç—Ä–∏ –æ–∫—Ä—É–∂–Ω–æ—Å—Ç–∏ –º—è—á–∞
            if (dx * dx + dy * dy <= ballRadius * ballRadius) {
                const pixelInfo = this.collisionGrid.checkPosition(ballX + dx, ballY + dy);
                
                if (pixelInfo.dangerLevel > 0) {
                    totalDanger += pixelInfo.dangerLevel;
                    checkedPixels++;
                    
                    if (pixelInfo.dangerLevel > maxDangerLevel) {
                        maxDangerLevel = pixelInfo.dangerLevel;
                        bestEscapeDirection = pixelInfo.escapeDirection;
                    }
                }
            }
        }
    }
    
    // –ò—Å–ø–æ–ª—å–∑—É–µ–º —Å—Ä–µ–¥–Ω—é—é –æ–ø–∞—Å–Ω–æ—Å—Ç—å –¥–ª—è –ø—Ä–∏–Ω—è—Ç–∏—è —Ä–µ—à–µ–Ω–∏—è
    const avgDangerLevel = checkedPixels > 0 ? totalDanger / checkedPixels : 0;
    
    // –ü—Ä–∏–º–µ–Ω—è–µ–º escape force —Ç–æ–ª—å–∫–æ –ø—Ä–∏ —Ä–µ–∞–ª—å–Ω–æ–π –æ–ø–∞—Å–Ω–æ—Å—Ç–∏
    if (avgDangerLevel > 0.8 && bestEscapeDirection) {
        const escapeForce = avgDangerLevel * 0.3;
        
        this.ball.velocity.x += bestEscapeDirection.x * escapeForce;
        this.ball.velocity.y += bestEscapeDirection.y * escapeForce;
        
        console.log(`üö® Pixel-perfect danger (avg: ${avgDangerLevel.toFixed(2)}, max: ${maxDangerLevel.toFixed(2)}), applying escape force`);
    }
}

‚úÖ –®–ê–ì 3: –î–æ–±–∞–≤–ª–µ–Ω–∏–µ –Ω–æ–≤—ã—Ö –º–µ—Ç–æ–¥–æ–≤
–î–û–ë–ê–í–ò–¢–¨ –ü–û–°–õ–ï –º–µ—Ç–æ–¥–∞ checkGridBasedCollisions() —Å–ª–µ–¥—É—é—â–∏–µ 3 –ù–û–í–´–• –ú–ï–¢–û–î–ê:
javascript// –ü–∏–∫—Å–µ–ª—å–Ω–æ-—Ç–æ—á–Ω–∞—è —Ä–∞—Å—Ç–µ—Ä–∏–∑–∞—Ü–∏—è —Å—Ç–µ–Ω
rasterizeWallPixelPerfect(wall, solidGrid, cols, rows) {
    const x1 = Math.round(wall.x1);
    const y1 = Math.round(wall.y1);
    const x2 = Math.round(wall.x2);
    const y2 = Math.round(wall.y2);
    
    const dx = Math.abs(x2 - x1);
    const dy = Math.abs(y2 - y1);
    const sx = x1 < x2 ? 1 : -1;
    const sy = y1 < y2 ? 1 : -1;
    let err = dx - dy;
    
    let x = x1;
    let y = y1;
    
    while (true) {
        const wallWidth = Math.max(wall.width || 5, 3);
        const radius = Math.floor(wallWidth / 2);
        
        for (let dy = -radius; dy <= radius; dy++) {
            for (let dx = -radius; dx <= radius; dx++) {
                const px = x + dx;
                const py = y + dy;
                
                if (px >= 0 && px < cols && py >= 0 && py < rows) {
                    if (dx * dx + dy * dy <= radius * radius) {
                        const index = py * cols + px;
                        solidGrid[index] = 1;
                    }
                }
            }
        }
        
        if (x === x2 && y === y2) break;
        
        const e2 = 2 * err;
        if (e2 > -dy) {
            err -= dy;
            x += sx;
        }
        if (e2 < dx) {
            err += dx;
            y += sy;
        }
    }
}

// –û–ø—Ç–∏–º–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω—ã–π —Ä–∞—Å—á–µ—Ç danger levels
computeDangerLevelsPixelPerfect(solidGrid, dangerGrid, cols, rows) {
    for (let row = 1; row < rows - 1; row++) {
        for (let col = 1; col < cols - 1; col++) {
            const index = row * cols + col;
            
            if (solidGrid[index]) {
                dangerGrid[index] = 0;
                continue;
            }
            
            let solidNeighbors = 0;
            let totalNeighbors = 0;
            
            for (let dr = -1; dr <= 1; dr++) {
                for (let dc = -1; dc <= 1; dc++) {
                    if (dr === 0 && dc === 0) continue;
                    
                    const neighborIndex = (row + dr) * cols + (col + dc);
                    totalNeighbors++;
                    if (solidGrid[neighborIndex]) {
                        solidNeighbors++;
                    }
                }
            }
            
            dangerGrid[index] = totalNeighbors > 0 ? solidNeighbors / totalNeighbors : 0;
        }
    }
}

// Escape directions —Ç–æ–ª—å–∫–æ –¥–ª—è –æ–ø–∞—Å–Ω—ã—Ö –ø–∏–∫—Å–µ–ª–µ–π
computeEscapeDirectionsPixelPerfect(dangerGrid, escapeXGrid, escapeYGrid, cols, rows) {
    for (let row = 2; row < rows - 2; row++) {
        for (let col = 2; col < cols - 2; col++) {
            const index = row * cols + col;
            
            if (dangerGrid[index] > 0.7) {
                let bestDirection = null;
                let bestSafety = -1;
                
                for (let dr = -5; dr <= 5; dr++) {
                    for (let dc = -5; dc <= 5; dc++) {
                        if (dr === 0 && dc === 0) continue;
                        
                        const checkRow = row + dr;
                        const checkCol = col + dc;
                        
                        if (checkRow >= 0 && checkRow < rows && checkCol >= 0 && checkCol < cols) {
                            const checkIndex = checkRow * cols + checkCol;
                            const safety = 1 - dangerGrid[checkIndex];
                            const distance = Math.sqrt(dr * dr + dc * dc);
                            
                            const score = safety - (distance * 0.05);
                            
                            if (score > bestSafety) {
                                bestSafety = score;
                                bestDirection = { x: dc, y: dr };
                            }
                        }
                    }
                }
                
                if (bestDirection) {
                    const length = Math.sqrt(bestDirection.x ** 2 + bestDirection.y ** 2);
                    escapeXGrid[index] = bestDirection.x / length;
                    escapeYGrid[index] = bestDirection.y / length;
                }
            }
        }
    }
}

‚úÖ –®–ê–ì 4: –£–¥–∞–ª–µ–Ω–∏–µ —Å—Ç–∞—Ä—ã—Ö –º–µ—Ç–æ–¥–æ–≤
–£–î–ê–õ–ò–¢–¨ —Å–ª–µ–¥—É—é—â–∏–µ –º–µ—Ç–æ–¥—ã (–æ–Ω–∏ –±–æ–ª—å—à–µ –Ω–µ –Ω—É–∂–Ω—ã):

markWallCells()
computeDangerLevels()
computeEscapeDirections()