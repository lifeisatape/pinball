// üöÄ –ü–†–û–°–¢–û–ï –¢–ï–°–¢–ò–†–û–í–ê–ù–ò–ï - –¥–æ–±–∞–≤–∏—Ç—å –≤ –Ω–∞—á–∞–ª–æ PinballGame.js

class PinballGame {
    constructor() {
        // ... —Å—É—â–µ—Å—Ç–≤—É—é—â–∏–π –∫–æ–¥ ...
        
        // ===== –î–û–ë–ê–í–ò–¢–¨ –î–õ–Ø –¢–ï–°–¢–ò–†–û–í–ê–ù–ò–Ø =====
        this.useCollisionGrid = true; // –í–∫–ª—é—á–∏—Ç—å/–≤—ã–∫–ª—é—á–∏—Ç—å —Å–µ—Ç–∫—É –∫–æ–ª–ª–∏–∑–∏–π
        this.collisionGrid = null;
        // ===== –ö–û–ù–ï–¶ –î–û–ë–ê–í–õ–ï–ù–ò–Ø =====
    }

    async initializeGame() {
        // ... —Å—É—â–µ—Å—Ç–≤—É—é—â–∏–π –∫–æ–¥ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏–∏ ...
        
        // ===== –î–û–ë–ê–í–ò–¢–¨ –ü–û–°–õ–ï –ó–ê–ì–†–£–ó–ö–ò –£–†–û–í–ù–Ø =====
        if (this.useCollisionGrid && this.currentLevel) {
            console.log('üîç Creating collision grid...');
            
            // –ü—Ä–æ—Å—Ç–∞—è –≤–µ—Ä—Å–∏—è —Å–µ—Ç–∫–∏ –∫–æ–ª–ª–∏–∑–∏–π
            this.collisionGrid = this.createSimpleCollisionGrid();
            
            console.log('‚úÖ Collision grid ready!');
        }
        // ===== –ö–û–ù–ï–¶ –î–û–ë–ê–í–õ–ï–ù–ò–Ø =====
    }

    // ===== –ü–†–û–°–¢–ê–Ø –í–ï–†–°–ò–Ø –°–ï–¢–ö–ò –ö–û–õ–õ–ò–ó–ò–ô =====
    createSimpleCollisionGrid() {
        const cellSize = 16;
        const cols = Math.ceil(CONFIG.VIRTUAL_WIDTH / cellSize);
        const rows = Math.ceil(CONFIG.VIRTUAL_HEIGHT / cellSize);
        
        const grid = [];
        
        // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä—É–µ–º —Å–µ—Ç–∫—É
        for (let row = 0; row < rows; row++) {
            grid[row] = [];
            for (let col = 0; col < cols; col++) {
                grid[row][col] = {
                    solid: false,
                    dangerLevel: 0,    // 0 = –±–µ–∑–æ–ø–∞—Å–Ω–æ, 1 = –æ–ø–∞—Å–Ω–æ
                    escapeDirection: null
                };
            }
        }
        
        // –û—Ç–º–µ—á–∞–µ–º —è—á–µ–π–∫–∏ —Å–æ —Å—Ç–µ–Ω–∞–º–∏
        this.currentLevel.walls.forEach(wall => {
            this.markWallCells(grid, wall, cellSize, cols, rows);
        });
        
        // –í—ã—á–∏—Å–ª—è–µ–º —É—Ä–æ–≤–Ω–∏ –æ–ø–∞—Å–Ω–æ—Å—Ç–∏ –∏ –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏—è —ç–≤–∞–∫—É–∞—Ü–∏–∏
        this.computeDangerLevels(grid, cols, rows);
        this.computeEscapeDirections(grid, cols, rows, cellSize);
        
        return {
            grid: grid,
            cellSize: cellSize,
            cols: cols,
            rows: rows,
            
            // –ë—ã—Å—Ç—Ä–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞
            checkPosition: (x, y) => {
                const col = Math.floor(x / cellSize);
                const row = Math.floor(y / cellSize);
                
                if (row >= 0 && row < rows && col >= 0 && col < cols) {
                    return grid[row][col];
                }
                return { solid: false, dangerLevel: 0, escapeDirection: null };
            }
        };
    }
    
    markWallCells(grid, wall, cellSize, cols, rows) {
        // –ü—Ä–æ—Å—Ç–∞—è —Ä–∞—Å—Ç–µ—Ä–∏–∑–∞—Ü–∏—è —Å—Ç–µ–Ω—ã
        const steps = Math.max(
            Math.abs(wall.x2 - wall.x1), 
            Math.abs(wall.y2 - wall.y1)
        ) / cellSize;
        
        for (let i = 0; i <= steps; i++) {
            const t = i / steps;
            const x = wall.x1 + (wall.x2 - wall.x1) * t;
            const y = wall.y1 + (wall.y2 - wall.y1) * t;
            
            const col = Math.floor(x / cellSize);
            const row = Math.floor(y / cellSize);
            
            // –û—Ç–º–µ—á–∞–µ–º —è—á–µ–π–∫—É –∏ —Å–æ—Å–µ–¥–Ω–∏–µ (–¥–ª—è —Ç–æ–ª—â–∏–Ω—ã —Å—Ç–µ–Ω—ã)
            for (let dr = -1; dr <= 1; dr++) {
                for (let dc = -1; dc <= 1; dc++) {
                    const newRow = row + dr;
                    const newCol = col + dc;
                    
                    if (newRow >= 0 && newRow < rows && newCol >= 0 && newCol < cols) {
                        grid[newRow][newCol].solid = true;
                    }
                }
            }
        }
    }
    
    computeDangerLevels(grid, cols, rows) {
        for (let row = 0; row < rows; row++) {
            for (let col = 0; col < cols; col++) {
                let solidNeighbors = 0;
                let totalNeighbors = 0;
                
                // –ü—Ä–æ–≤–µ—Ä—è–µ–º —Å–æ—Å–µ–¥–µ–π 3x3
                for (let dr = -1; dr <= 1; dr++) {
                    for (let dc = -1; dc <= 1; dc++) {
                        if (dr === 0 && dc === 0) continue;
                        
                        const newRow = row + dr;
                        const newCol = col + dc;
                        
                        if (newRow >= 0 && newRow < rows && newCol >= 0 && newCol < cols) {
                            totalNeighbors++;
                            if (grid[newRow][newCol].solid) {
                                solidNeighbors++;
                            }
                        }
                    }
                }
                
                // –£—Ä–æ–≤–µ–Ω—å –æ–ø–∞—Å–Ω–æ—Å—Ç–∏ = –¥–æ–ª—è —Ç–≤–µ—Ä–¥—ã—Ö —Å–æ—Å–µ–¥–µ–π
                grid[row][col].dangerLevel = totalNeighbors > 0 ? solidNeighbors / totalNeighbors : 0;
            }
        }
    }
    
    computeEscapeDirections(grid, cols, rows, cellSize) {
        for (let row = 0; row < rows; row++) {
            for (let col = 0; col < cols; col++) {
                if (grid[row][col].dangerLevel > 0.3) {
                    // –û–ø–∞—Å–Ω–∞—è —è—á–µ–π–∫–∞ - –∏—â–µ–º –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –∫ –±–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç–∏
                    let bestDirection = null;
                    let bestSafety = -1;
                    
                    // –ü—Ä–æ–≤–µ—Ä—è–µ–º –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏—è
                    for (let dr = -2; dr <= 2; dr++) {
                        for (let dc = -2; dc <= 2; dc++) {
                            if (dr === 0 && dc === 0) continue;
                            
                            const newRow = row + dr;
                            const newCol = col + dc;
                            
                            if (newRow >= 0 && newRow < rows && newCol >= 0 && newCol < cols) {
                                const safety = 1 - grid[newRow][newCol].dangerLevel;
                                if (safety > bestSafety) {
                                    bestSafety = safety;
                                    bestDirection = { x: dc, y: dr };
                                }
                            }
                        }
                    }
                    
                    if (bestDirection) {
                        const length = Math.sqrt(bestDirection.x ** 2 + bestDirection.y ** 2);
                        grid[row][col].escapeDirection = {
                            x: bestDirection.x / length,
                            y: bestDirection.y / length
                        };
                    }
                }
            }
        }
    }

    // ===== –£–õ–£–ß–®–ï–ù–ù–ê–Ø –ü–†–û–í–ï–†–ö–ê –ö–û–õ–õ–ò–ó–ò–ô =====
    checkCollisions() {
        // –ü—Ä–æ–≤–µ—Ä—è–µ–º —á–µ—Ä–µ–∑ —Å–µ—Ç–∫—É –∫–æ–ª–ª–∏–∑–∏–π
        if (this.useCollisionGrid && this.collisionGrid) {
            this.checkGridBasedCollisions();
        }
        
        // –û–±—ã—á–Ω—ã–µ –ø—Ä–æ–≤–µ—Ä–∫–∏ —Å—Ç–µ–Ω (–Ω–æ —Ç–æ–ª—å–∫–æ –æ–¥–Ω–∞ –∏—Ç–µ—Ä–∞—Ü–∏—è)
        this.currentLevel.walls.forEach(wall => {
            wall.checkCollision(this.ball);
        });

        // –û—Å—Ç–∞–ª—å–Ω—ã–µ –∫–æ–ª–ª–∏–∑–∏–∏ –±–µ–∑ –∏–∑–º–µ–Ω–µ–Ω–∏–π
        this.currentLevel.flippers.forEach(flipper => {
            flipper.checkCollision(this.ball);
        });

        this.currentLevel.bumpers.forEach(bumper => {
            const points = bumper.checkCollision(this.ball);
            if (points > 0) {
                this.gameState.updateScore(points);
                this.scorePanel.updateScore(this.gameState.score);
                this.scorePanel.updateHighScore(this.gameState.highScore);
                window.soundManager?.playSound('bumper');
            }
        });

        // ... –æ—Å—Ç–∞–ª—å–Ω—ã–µ –∫–æ–ª–ª–∏–∑–∏–∏
    }
    
    checkGridBasedCollisions() {
        const ballInfo = this.collisionGrid.checkPosition(
            this.ball.position.x, 
            this.ball.position.y
        );
        
        // –ï—Å–ª–∏ –º—è—á –≤ –æ–ø–∞—Å–Ω–æ–π –∑–æ–Ω–µ
        if (ballInfo.dangerLevel > 0.5 && ballInfo.escapeDirection) {
            // –ú—è–≥–∫–æ –Ω–∞–ø—Ä–∞–≤–ª—è–µ–º –º—è—á –∫ –±–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç–∏
            const escapeForce = ballInfo.dangerLevel * 0.5; // –°–∏–ª–∞ –∑–∞–≤–∏—Å–∏—Ç –æ—Ç –æ–ø–∞—Å–Ω–æ—Å—Ç–∏
            
            this.ball.velocity.x += ballInfo.escapeDirection.x * escapeForce;
            this.ball.velocity.y += ballInfo.escapeDirection.y * escapeForce;
            
            console.log(`üö® Ball in danger zone (${ballInfo.dangerLevel.toFixed(2)}), applying escape force`);
        }
    }

    // ===== –ü–†–û–°–¢–ê–Ø –û–¢–õ–ê–î–ö–ê =====
    drawCollisionGridDebug() {
        if (!this.collisionGrid) return;
        
        const ctx = this.renderer.ctx;
        if (!ctx) return;
        
        ctx.save();
        ctx.globalAlpha = 0.3;
        
        // –†–∏—Å—É–µ–º —Å–µ—Ç–∫—É
        for (let row = 0; row < this.collisionGrid.rows; row++) {
            for (let col = 0; col < this.collisionGrid.cols; col++) {
                const cell = this.collisionGrid.grid[row][col];
                const x = col * this.collisionGrid.cellSize;
                const y = row * this.collisionGrid.cellSize;
                
                if (cell.solid) {
                    ctx.fillStyle = '#ff0000';
                    ctx.fillRect(x, y, this.collisionGrid.cellSize, this.collisionGrid.cellSize);
                } else if (cell.dangerLevel > 0.3) {
                    const intensity = Math.floor(cell.dangerLevel * 255);
                    ctx.fillStyle = `rgb(${intensity}, ${255 - intensity}, 0)`;
                    ctx.fillRect(x, y, this.collisionGrid.cellSize, this.collisionGrid.cellSize);
                }
            }
        }
        
        ctx.restore();
    }
}

// ===== –ê–ö–¢–ò–í–ê–¶–ò–Ø –û–¢–õ–ê–î–ö–ò =====
// –î–æ–±–∞–≤–∏—Ç—å –≤ draw() –º–µ—Ç–æ–¥:

draw() {
    // ... —Å—É—â–µ—Å—Ç–≤—É—é—â–∏–π –∫–æ–¥ —Ä–µ–Ω–¥–µ—Ä–∏–Ω–≥–∞ ...
    
    // ===== –î–û–ë–ê–í–ò–¢–¨ –í –ö–û–ù–ï–¶ =====
    // –û—Ç–ª–∞–¥–æ—á–Ω–∞—è –≤–∏–∑—É–∞–ª–∏–∑–∞—Ü–∏—è (–≤–∫–ª—é—á–∏—Ç—å –¥–ª—è —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏—è)
    if (this.useCollisionGrid && false) { // –ü–æ–º–µ–Ω—è–π false –Ω–∞ true –¥–ª—è –≤–∫–ª—é—á–µ–Ω–∏—è
        this.drawCollisionGridDebug();
    }
    // ===== –ö–û–ù–ï–¶ –î–û–ë–ê–í–õ–ï–ù–ò–Ø =====
}