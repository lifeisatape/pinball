
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pinball Level Editor</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            user-select: none;
        }

        body {
            font-family: 'Courier New', monospace;
            background: #222;
            color: #00ff00;
            overflow: hidden;
        }

        .editor-container {
            display: flex;
            height: 100vh;
        }

        .toolbar {
            width: 200px;
            background: #333;
            padding: 10px;
            border-right: 2px solid #555;
            overflow-y: auto;
        }

        .tool-section {
            margin-bottom: 20px;
        }

        .tool-section h3 {
            color: #00ff00;
            margin-bottom: 10px;
            font-size: 14px;
        }

        .tool-btn {
            display: block;
            width: 100%;
            padding: 8px;
            margin-bottom: 5px;
            background: #444;
            color: #00ff00;
            border: none;
            cursor: pointer;
            font-family: 'Courier New', monospace;
            font-size: 12px;
        }

        .tool-btn:hover {
            background: #555;
        }

        .tool-btn.active {
            background: #006600;
            color: white;
        }

        .input-group {
            margin-bottom: 10px;
        }

        .input-group label {
            display: block;
            font-size: 11px;
            margin-bottom: 3px;
        }

        .input-group input {
            width: 100%;
            padding: 4px;
            background: #444;
            color: #00ff00;
            border: 1px solid #555;
            font-family: 'Courier New', monospace;
        }

        .editor-canvas-container {
            flex: 1;
            position: relative;
            background: #000;
        }

        #editorCanvas {
            display: block;
            cursor: crosshair;
        }

        .mode-indicator {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(0, 0, 0, 0.8);
            color: #00ff00;
            padding: 5px 10px;
            font-size: 12px;
        }

        .coordinates {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(0, 0, 0, 0.8);
            color: #00ff00;
            padding: 5px 10px;
            font-size: 12px;
        }

        .test-mode-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.9);
            display: none;
            z-index: 100;
        }

        .test-controls {
            position: absolute;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.8);
            padding: 10px;
            border-radius: 5px;
        }

        .test-controls button {
            margin: 0 5px;
            padding: 5px 10px;
            background: #444;
            color: #00ff00;
            border: none;
            cursor: pointer;
            font-family: 'Courier New', monospace;
        }
    </style>
</head>
<body>
    <div class="editor-container">
        <div class="toolbar">
            <div class="tool-section">
                <h3>TOOLS</h3>
                <button class="tool-btn active" data-tool="wall">Draw Wall</button>
                <button class="tool-btn" data-tool="bumper">Place Bumper</button>
                <button class="tool-btn" data-tool="spinner">Place Spinner</button>
                <button class="tool-btn" data-tool="droptarget">Place Drop Target</button>
                <button class="tool-btn" data-tool="select">Select/Move</button>
                <button class="tool-btn" data-tool="delete">Delete</button>
            </div>

            <div class="tool-section">
                <h3>WALL SETTINGS</h3>
                <div class="input-group">
                    <label>Width:</label>
                    <input type="number" id="wallWidth" value="20" min="5" max="50">
                </div>
                <div class="input-group">
                    <label>Color:</label>
                    <input type="color" id="wallColor" value="#ff4444">
                </div>
            </div>

            <div class="tool-section">
                <h3>OBJECT SETTINGS</h3>
                <div class="input-group">
                    <label>Bumper Radius:</label>
                    <input type="number" id="bumperRadius" value="25" min="10" max="50">
                </div>
                <div class="input-group">
                    <label>Spinner Width:</label>
                    <input type="number" id="spinnerWidth" value="30" min="20" max="50">
                </div>
            </div>

            <div class="tool-section">
                <h3>ACTIONS</h3>
                <button class="tool-btn" id="testLevel">Test Level</button>
                <button class="tool-btn" id="clearLevel">Clear All</button>
                <button class="tool-btn" id="saveLevel">Save Level</button>
                <button class="tool-btn" id="loadLevel">Load Level</button>
            </div>

            <div class="tool-section">
                <h3>GRID</h3>
                <div class="input-group">
                    <label>
                        <input type="checkbox" id="showGrid" checked> Show Grid
                    </label>
                </div>
                <div class="input-group">
                    <label>Grid Size:</label>
                    <input type="number" id="gridSize" value="20" min="10" max="50">
                </div>
            </div>
        </div>

        <div class="editor-canvas-container">
            <canvas id="editorCanvas"></canvas>
            <div class="mode-indicator" id="modeIndicator">WALL MODE</div>
            <div class="coordinates" id="coordinates">X: 0, Y: 0</div>
            
            <div class="test-mode-overlay" id="testModeOverlay">
                <canvas id="testCanvas"></canvas>
                <div class="test-controls">
                    <button id="exitTest">Exit Test</button>
                    <button id="resetBall">Reset Ball</button>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Import game classes and config
        const CONFIG = {
            GRAVITY: 0.3,
            FRICTION: 0.98,
            BOUNCE_DAMPING: 0.8,
            FLIPPER_STRENGTH: 12,
            BALL_RADIUS: 8,
            FLIPPER_LENGTH: 50,
            FLIPPER_WIDTH: 8,
            LAUNCH_POWER: 20,
            MAX_BALL_SPEED: 25,
            VIRTUAL_WIDTH: 320,
            VIRTUAL_HEIGHT: 480
        };

        // Level Editor Class
        class LevelEditor {
            constructor() {
                this.canvas = document.getElementById('editorCanvas');
                this.ctx = this.canvas.getContext('2d');
                this.testCanvas = document.getElementById('testCanvas');
                this.testCtx = this.testCanvas.getContext('2d');
                
                this.currentTool = 'wall';
                this.isDrawing = false;
                this.drawStart = null;
                this.selectedObject = null;
                this.mousePos = { x: 0, y: 0 };
                
                // Level data
                this.walls = [];
                this.bumpers = [];
                this.spinners = [];
                this.dropTargets = [];
                
                // Fixed flipper positions
                this.flippers = [
                    { x: CONFIG.VIRTUAL_WIDTH * 0.3, y: CONFIG.VIRTUAL_HEIGHT - 80, isLeft: true },
                    { x: CONFIG.VIRTUAL_WIDTH * 0.7, y: CONFIG.VIRTUAL_HEIGHT - 80, isLeft: false }
                ];
                
                this.scale = 1;
                this.offsetX = 0;
                this.offsetY = 0;
                
                this.setupCanvas();
                this.setupEventListeners();
                this.setupTestMode();
                
                this.render();
            }
            
            setupCanvas() {
                this.resizeCanvas();
                window.addEventListener('resize', () => this.resizeCanvas());
            }
            
            resizeCanvas() {
                const container = this.canvas.parentElement;
                this.canvas.width = container.clientWidth;
                this.canvas.height = container.clientHeight;
                
                this.testCanvas.width = container.clientWidth;
                this.testCanvas.height = container.clientHeight;
                
                const scaleX = this.canvas.width / CONFIG.VIRTUAL_WIDTH;
                const scaleY = this.canvas.height / CONFIG.VIRTUAL_HEIGHT;
                this.scale = Math.min(scaleX, scaleY);
                
                this.offsetX = (this.canvas.width - CONFIG.VIRTUAL_WIDTH * this.scale) / 2;
                this.offsetY = (this.canvas.height - CONFIG.VIRTUAL_HEIGHT * this.scale) / 2;
            }
            
            setupEventListeners() {
                // Tool selection
                document.querySelectorAll('.tool-btn[data-tool]').forEach(btn => {
                    btn.addEventListener('click', (e) => {
                        document.querySelectorAll('.tool-btn[data-tool]').forEach(b => b.classList.remove('active'));
                        btn.classList.add('active');
                        this.currentTool = btn.dataset.tool;
                        this.updateModeIndicator();
                    });
                });
                
                // Canvas events
                this.canvas.addEventListener('mousedown', (e) => this.handleMouseDown(e));
                this.canvas.addEventListener('mousemove', (e) => this.handleMouseMove(e));
                this.canvas.addEventListener('mouseup', (e) => this.handleMouseUp(e));
                
                // Action buttons
                document.getElementById('testLevel').addEventListener('click', () => this.enterTestMode());
                document.getElementById('clearLevel').addEventListener('click', () => this.clearLevel());
                document.getElementById('saveLevel').addEventListener('click', () => this.saveLevel());
                document.getElementById('loadLevel').addEventListener('click', () => this.loadLevel());
                
                // Test mode controls
                document.getElementById('exitTest').addEventListener('click', () => this.exitTestMode());
                document.getElementById('resetBall').addEventListener('click', () => this.resetTestBall());
            }
            
            screenToWorld(screenX, screenY) {
                return {
                    x: (screenX - this.offsetX) / this.scale,
                    y: (screenY - this.offsetY) / this.scale
                };
            }
            
            worldToScreen(worldX, worldY) {
                return {
                    x: worldX * this.scale + this.offsetX,
                    y: worldY * this.scale + this.offsetY
                };
            }
            
            handleMouseDown(e) {
                const rect = this.canvas.getBoundingClientRect();
                const screenX = e.clientX - rect.left;
                const screenY = e.clientY - rect.top;
                const worldPos = this.screenToWorld(screenX, screenY);
                
                if (this.currentTool === 'wall') {
                    this.isDrawing = true;
                    this.drawStart = worldPos;
                } else if (this.currentTool === 'bumper') {
                    const radius = parseInt(document.getElementById('bumperRadius').value);
                    this.bumpers.push({
                        x: worldPos.x,
                        y: worldPos.y,
                        radius: radius,
                        points: 100
                    });
                } else if (this.currentTool === 'spinner') {
                    const width = parseInt(document.getElementById('spinnerWidth').value);
                    this.spinners.push({
                        x: worldPos.x,
                        y: worldPos.y,
                        width: width,
                        height: 8,
                        angle: 0,
                        points: 50
                    });
                } else if (this.currentTool === 'droptarget') {
                    this.dropTargets.push({
                        x: worldPos.x,
                        y: worldPos.y,
                        width: 15,
                        height: 30,
                        isActive: true,
                        points: 200
                    });
                } else if (this.currentTool === 'delete') {
                    this.deleteObjectAt(worldPos);
                }
                
                this.render();
            }
            
            handleMouseMove(e) {
                const rect = this.canvas.getBoundingClientRect();
                const screenX = e.clientX - rect.left;
                const screenY = e.clientY - rect.top;
                const worldPos = this.screenToWorld(screenX, screenY);
                
                this.mousePos = worldPos;
                document.getElementById('coordinates').textContent = `X: ${Math.round(worldPos.x)}, Y: ${Math.round(worldPos.y)}`;
                
                this.render();
            }
            
            handleMouseUp(e) {
                if (this.isDrawing && this.currentTool === 'wall') {
                    const rect = this.canvas.getBoundingClientRect();
                    const screenX = e.clientX - rect.left;
                    const screenY = e.clientY - rect.top;
                    const worldPos = this.screenToWorld(screenX, screenY);
                    
                    const width = parseInt(document.getElementById('wallWidth').value);
                    const color = document.getElementById('wallColor').value;
                    
                    this.walls.push({
                        x1: this.drawStart.x,
                        y1: this.drawStart.y,
                        x2: worldPos.x,
                        y2: worldPos.y,
                        width: width,
                        color: color
                    });
                    
                    this.isDrawing = false;
                    this.drawStart = null;
                }
                
                this.render();
            }
            
            deleteObjectAt(worldPos) {
                const tolerance = 20;
                
                // Check walls
                this.walls = this.walls.filter(wall => {
                    const dist = this.distanceToLine(worldPos, wall);
                    return dist > tolerance;
                });
                
                // Check bumpers
                this.bumpers = this.bumpers.filter(bumper => {
                    const dist = Math.sqrt((worldPos.x - bumper.x) ** 2 + (worldPos.y - bumper.y) ** 2);
                    return dist > bumper.radius;
                });
                
                // Check spinners
                this.spinners = this.spinners.filter(spinner => {
                    const dist = Math.sqrt((worldPos.x - spinner.x) ** 2 + (worldPos.y - spinner.y) ** 2);
                    return dist > spinner.width / 2;
                });
                
                // Check drop targets
                this.dropTargets = this.dropTargets.filter(target => {
                    const dx = Math.abs(worldPos.x - target.x);
                    const dy = Math.abs(worldPos.y - target.y);
                    return dx > target.width / 2 || dy > target.height / 2;
                });
            }
            
            distanceToLine(point, wall) {
                const A = point.x - wall.x1;
                const B = point.y - wall.y1;
                const C = wall.x2 - wall.x1;
                const D = wall.y2 - wall.y1;
                
                const dot = A * C + B * D;
                const lenSq = C * C + D * D;
                
                if (lenSq === 0) return Math.sqrt(A * A + B * B);
                
                const param = dot / lenSq;
                let xx, yy;
                
                if (param < 0) {
                    xx = wall.x1;
                    yy = wall.y1;
                } else if (param > 1) {
                    xx = wall.x2;
                    yy = wall.y2;
                } else {
                    xx = wall.x1 + param * C;
                    yy = wall.y1 + param * D;
                }
                
                const dx = point.x - xx;
                const dy = point.y - yy;
                return Math.sqrt(dx * dx + dy * dy);
            }
            
            updateModeIndicator() {
                const modes = {
                    wall: 'WALL MODE',
                    bumper: 'BUMPER MODE',
                    spinner: 'SPINNER MODE',
                    droptarget: 'DROP TARGET MODE',
                    select: 'SELECT MODE',
                    delete: 'DELETE MODE'
                };
                document.getElementById('modeIndicator').textContent = modes[this.currentTool] || 'UNKNOWN MODE';
            }
            
            render() {
                // Clear canvas
                this.ctx.fillStyle = '#000';
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
                
                this.ctx.save();
                this.ctx.translate(this.offsetX, this.offsetY);
                this.ctx.scale(this.scale, this.scale);
                
                // Draw background
                const gradient = this.ctx.createLinearGradient(0, 0, 0, CONFIG.VIRTUAL_HEIGHT);
                gradient.addColorStop(0, '#1a1a2e');
                gradient.addColorStop(1, '#0f1419');
                this.ctx.fillStyle = gradient;
                this.ctx.fillRect(0, 0, CONFIG.VIRTUAL_WIDTH, CONFIG.VIRTUAL_HEIGHT);
                
                // Draw grid
                if (document.getElementById('showGrid').checked) {
                    this.drawGrid();
                }
                
                // Draw game boundaries
                this.ctx.strokeStyle = '#666';
                this.ctx.lineWidth = 2;
                this.ctx.strokeRect(0, 0, CONFIG.VIRTUAL_WIDTH, CONFIG.VIRTUAL_HEIGHT);
                
                // Draw walls
                this.walls.forEach(wall => {
                    this.ctx.strokeStyle = wall.color;
                    this.ctx.lineWidth = wall.width;
                    this.ctx.lineCap = 'round';
                    this.ctx.beginPath();
                    this.ctx.moveTo(wall.x1, wall.y1);
                    this.ctx.lineTo(wall.x2, wall.y2);
                    this.ctx.stroke();
                });
                
                // Draw bumpers
                this.bumpers.forEach(bumper => {
                    const gradient = this.ctx.createRadialGradient(
                        bumper.x - 5, bumper.y - 5, 0,
                        bumper.x, bumper.y, bumper.radius
                    );
                    gradient.addColorStop(0, '#ffffff');
                    gradient.addColorStop(0.3, '#ff4444');
                    gradient.addColorStop(1, '#aa0000');
                    
                    this.ctx.fillStyle = gradient;
                    this.ctx.beginPath();
                    this.ctx.arc(bumper.x, bumper.y, bumper.radius, 0, Math.PI * 2);
                    this.ctx.fill();
                    
                    this.ctx.strokeStyle = '#ffffff';
                    this.ctx.lineWidth = 2;
                    this.ctx.stroke();
                });
                
                // Draw spinners
                this.spinners.forEach(spinner => {
                    this.ctx.save();
                    this.ctx.translate(spinner.x, spinner.y);
                    this.ctx.rotate(spinner.angle || 0);
                    
                    const gradient = this.ctx.createLinearGradient(-spinner.width/2, 0, spinner.width/2, 0);
                    gradient.addColorStop(0, '#4444ff');
                    gradient.addColorStop(0.5, '#6666ff');
                    gradient.addColorStop(1, '#4444ff');
                    
                    this.ctx.fillStyle = gradient;
                    this.ctx.fillRect(-spinner.width/2, -spinner.height/2, spinner.width, spinner.height);
                    
                    this.ctx.strokeStyle = '#ffffff';
                    this.ctx.lineWidth = 1;
                    this.ctx.strokeRect(-spinner.width/2, -spinner.height/2, spinner.width, spinner.height);
                    
                    this.ctx.restore();
                    
                    this.ctx.fillStyle = '#ffffff';
                    this.ctx.beginPath();
                    this.ctx.arc(spinner.x, spinner.y, 3, 0, Math.PI * 2);
                    this.ctx.fill();
                });
                
                // Draw drop targets
                this.dropTargets.forEach(target => {
                    const gradient = this.ctx.createLinearGradient(
                        target.x - target.width/2, target.y,
                        target.x + target.width/2, target.y
                    );
                    gradient.addColorStop(0, '#ff8800');
                    gradient.addColorStop(0.5, '#ffaa00');
                    gradient.addColorStop(1, '#ff8800');
                    
                    this.ctx.fillStyle = gradient;
                    this.ctx.fillRect(
                        target.x - target.width/2,
                        target.y - target.height/2,
                        target.width,
                        target.height
                    );
                    
                    this.ctx.strokeStyle = '#ffffff';
                    this.ctx.lineWidth = 1;
                    this.ctx.strokeRect(
                        target.x - target.width/2,
                        target.y - target.height/2,
                        target.width,
                        target.height
                    );
                });
                
                // Draw flippers
                this.flippers.forEach(flipper => {
                    this.ctx.fillStyle = '#ff6666';
                    this.ctx.strokeStyle = '#ffffff';
                    this.ctx.lineWidth = 1.5;
                    
                    const length = CONFIG.FLIPPER_LENGTH;
                    const width = CONFIG.FLIPPER_WIDTH;
                    const angle = flipper.isLeft ? Math.PI / 8 : -Math.PI / 8;
                    
                    this.ctx.save();
                    this.ctx.translate(flipper.x, flipper.y);
                    this.ctx.rotate(angle);
                    
                    this.ctx.fillRect(-width/2, 0, width, length);
                    this.ctx.strokeRect(-width/2, 0, width, length);
                    
                    this.ctx.restore();
                    
                    this.ctx.fillStyle = '#ffffff';
                    this.ctx.beginPath();
                    this.ctx.arc(flipper.x, flipper.y, 5, 0, Math.PI * 2);
                    this.ctx.fill();
                });
                
                // Draw current drawing line
                if (this.isDrawing && this.drawStart) {
                    const width = parseInt(document.getElementById('wallWidth').value);
                    const color = document.getElementById('wallColor').value;
                    
                    this.ctx.strokeStyle = color;
                    this.ctx.lineWidth = width;
                    this.ctx.lineCap = 'round';
                    this.ctx.setLineDash([5, 5]);
                    this.ctx.beginPath();
                    this.ctx.moveTo(this.drawStart.x, this.drawStart.y);
                    this.ctx.lineTo(this.mousePos.x, this.mousePos.y);
                    this.ctx.stroke();
                    this.ctx.setLineDash([]);
                }
                
                this.ctx.restore();
            }
            
            drawGrid() {
                const gridSize = parseInt(document.getElementById('gridSize').value);
                this.ctx.strokeStyle = '#333';
                this.ctx.lineWidth = 1;
                
                for (let x = 0; x <= CONFIG.VIRTUAL_WIDTH; x += gridSize) {
                    this.ctx.beginPath();
                    this.ctx.moveTo(x, 0);
                    this.ctx.lineTo(x, CONFIG.VIRTUAL_HEIGHT);
                    this.ctx.stroke();
                }
                
                for (let y = 0; y <= CONFIG.VIRTUAL_HEIGHT; y += gridSize) {
                    this.ctx.beginPath();
                    this.ctx.moveTo(0, y);
                    this.ctx.lineTo(CONFIG.VIRTUAL_WIDTH, y);
                    this.ctx.stroke();
                }
            }
            
            clearLevel() {
                if (confirm('Clear all objects? This cannot be undone.')) {
                    this.walls = [];
                    this.bumpers = [];
                    this.spinners = [];
                    this.dropTargets = [];
                    this.render();
                }
            }
            
            saveLevel() {
                const levelData = {
                    walls: this.walls,
                    bumpers: this.bumpers,
                    spinners: this.spinners,
                    dropTargets: this.dropTargets
                };
                
                const dataStr = JSON.stringify(levelData, null, 2);
                const dataBlob = new Blob([dataStr], { type: 'application/json' });
                const url = URL.createObjectURL(dataBlob);
                
                const link = document.createElement('a');
                link.href = url;
                link.download = 'pinball_level.json';
                link.click();
                
                URL.revokeObjectURL(url);
            }
            
            loadLevel() {
                const input = document.createElement('input');
                input.type = 'file';
                input.accept = '.json';
                
                input.onchange = (e) => {
                    const file = e.target.files[0];
                    if (file) {
                        const reader = new FileReader();
                        reader.onload = (e) => {
                            try {
                                const levelData = JSON.parse(e.target.result);
                                this.walls = levelData.walls || [];
                                this.bumpers = levelData.bumpers || [];
                                this.spinners = levelData.spinners || [];
                                this.dropTargets = levelData.dropTargets || [];
                                this.render();
                            } catch (error) {
                                alert('Error loading level file: ' + error.message);
                            }
                        };
                        reader.readAsText(file);
                    }
                };
                
                input.click();
            }
            
            setupTestMode() {
                // Test mode will use simplified versions of game classes
                this.testGame = null;
            }
            
            enterTestMode() {
                document.getElementById('testModeOverlay').style.display = 'block';
                this.initTestGame();
            }
            
            exitTestMode() {
                document.getElementById('testModeOverlay').style.display = 'none';
                if (this.testGame) {
                    this.testGame.stop();
                    this.testGame = null;
                }
            }
            
            initTestGame() {
                this.testGame = new TestGame(this.testCanvas, this.testCtx, {
                    walls: this.walls,
                    bumpers: this.bumpers,
                    spinners: this.spinners,
                    dropTargets: this.dropTargets,
                    flippers: this.flippers
                });
            }
            
            resetTestBall() {
                if (this.testGame) {
                    this.testGame.resetBall();
                }
            }
        }
        
        // Simplified Test Game for level testing
        class TestGame {
            constructor(canvas, ctx, levelData) {
                this.canvas = canvas;
                this.ctx = ctx;
                this.levelData = levelData;
                this.running = true;
                
                const scaleX = this.canvas.width / CONFIG.VIRTUAL_WIDTH;
                const scaleY = this.canvas.height / CONFIG.VIRTUAL_HEIGHT;
                this.scale = Math.min(scaleX, scaleY);
                this.offsetX = (this.canvas.width - CONFIG.VIRTUAL_WIDTH * this.scale) / 2;
                this.offsetY = (this.canvas.height - CONFIG.VIRTUAL_HEIGHT * this.scale) / 2;
                
                this.ball = {
                    x: CONFIG.VIRTUAL_WIDTH * 0.5,
                    y: 50,
                    vx: 0,
                    vy: 0,
                    radius: CONFIG.BALL_RADIUS
                };
                
                this.leftFlipperActive = false;
                this.rightFlipperActive = false;
                
                this.setupControls();
                this.gameLoop();
            }
            
            setupControls() {
                this.keyHandler = (e) => {
                    if (e.code === 'ArrowLeft' || e.code === 'KeyA') {
                        this.leftFlipperActive = e.type === 'keydown';
                    }
                    if (e.code === 'ArrowRight' || e.code === 'KeyD') {
                        this.rightFlipperActive = e.type === 'keydown';
                    }
                };
                
                document.addEventListener('keydown', this.keyHandler);
                document.addEventListener('keyup', this.keyHandler);
            }
            
            stop() {
                this.running = false;
                document.removeEventListener('keydown', this.keyHandler);
                document.removeEventListener('keyup', this.keyHandler);
            }
            
            resetBall() {
                this.ball.x = CONFIG.VIRTUAL_WIDTH * 0.5;
                this.ball.y = 50;
                this.ball.vx = 0;
                this.ball.vy = 0;
            }
            
            update() {
                // Apply gravity
                this.ball.vy += CONFIG.GRAVITY;
                
                // Apply friction
                this.ball.vx *= CONFIG.FRICTION;
                this.ball.vy *= CONFIG.FRICTION;
                
                // Limit speed
                const speed = Math.sqrt(this.ball.vx * this.ball.vx + this.ball.vy * this.ball.vy);
                if (speed > CONFIG.MAX_BALL_SPEED) {
                    this.ball.vx = (this.ball.vx / speed) * CONFIG.MAX_BALL_SPEED;
                    this.ball.vy = (this.ball.vy / speed) * CONFIG.MAX_BALL_SPEED;
                }
                
                // Update position
                this.ball.x += this.ball.vx;
                this.ball.y += this.ball.vy;
                
                // Boundary collisions
                if (this.ball.x - this.ball.radius < 0) {
                    this.ball.x = this.ball.radius;
                    this.ball.vx = -this.ball.vx * CONFIG.BOUNCE_DAMPING;
                }
                if (this.ball.x + this.ball.radius > CONFIG.VIRTUAL_WIDTH) {
                    this.ball.x = CONFIG.VIRTUAL_WIDTH - this.ball.radius;
                    this.ball.vx = -this.ball.vx * CONFIG.BOUNCE_DAMPING;
                }
                if (this.ball.y - this.ball.radius < 0) {
                    this.ball.y = this.ball.radius;
                    this.ball.vy = -this.ball.vy * CONFIG.BOUNCE_DAMPING;
                }
                if (this.ball.y > CONFIG.VIRTUAL_HEIGHT + 50) {
                    this.resetBall();
                }
                
                // Wall collisions
                this.levelData.walls.forEach(wall => {
                    this.checkWallCollision(wall);
                });
                
                // Bumper collisions
                this.levelData.bumpers.forEach(bumper => {
                    this.checkBumperCollision(bumper);
                });
            }
            
            checkWallCollision(wall) {
                const distance = this.distanceToLine(this.ball, wall);
                
                if (distance < this.ball.radius + wall.width / 2) {
                    const normal = this.getNormalToLine(this.ball, wall);
                    
                    const overlap = this.ball.radius + wall.width / 2 - distance;
                    this.ball.x += normal.x * overlap;
                    this.ball.y += normal.y * overlap;
                    
                    const dotProduct = this.ball.vx * normal.x + this.ball.vy * normal.y;
                    this.ball.vx -= 2 * dotProduct * normal.x;
                    this.ball.vy -= 2 * dotProduct * normal.y;
                    this.ball.vx *= CONFIG.BOUNCE_DAMPING;
                    this.ball.vy *= CONFIG.BOUNCE_DAMPING;
                }
            }
            
            checkBumperCollision(bumper) {
                const dx = this.ball.x - bumper.x;
                const dy = this.ball.y - bumper.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                if (distance < this.ball.radius + bumper.radius) {
                    const normal = { x: dx / distance, y: dy / distance };
                    
                    const overlap = this.ball.radius + bumper.radius - distance + 2;
                    this.ball.x += normal.x * overlap;
                    this.ball.y += normal.y * overlap;
                    
                    const bounceForce = 15;
                    this.ball.vx = normal.x * bounceForce;
                    this.ball.vy = normal.y * bounceForce;
                }
            }
            
            distanceToLine(point, wall) {
                const A = point.x - wall.x1;
                const B = point.y - wall.y1;
                const C = wall.x2 - wall.x1;
                const D = wall.y2 - wall.y1;
                
                const dot = A * C + B * D;
                const lenSq = C * C + D * D;
                
                if (lenSq === 0) return Math.sqrt(A * A + B * B);
                
                const param = Math.max(0, Math.min(1, dot / lenSq));
                const xx = wall.x1 + param * C;
                const yy = wall.y1 + param * D;
                
                const dx = point.x - xx;
                const dy = point.y - yy;
                return Math.sqrt(dx * dx + dy * dy);
            }
            
            getNormalToLine(point, wall) {
                const dx = wall.x2 - wall.x1;
                const dy = wall.y2 - wall.y1;
                const normal = { x: -dy, y: dx };
                const length = Math.sqrt(normal.x * normal.x + normal.y * normal.y);
                
                if (length > 0) {
                    normal.x /= length;
                    normal.y /= length;
                }
                
                const toPoint = { x: point.x - wall.x1, y: point.y - wall.y1 };
                if (normal.x * toPoint.x + normal.y * toPoint.y < 0) {
                    normal.x = -normal.x;
                    normal.y = -normal.y;
                }
                
                return normal;
            }
            
            draw() {
                // Clear canvas
                this.ctx.fillStyle = '#000';
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
                
                this.ctx.save();
                this.ctx.translate(this.offsetX, this.offsetY);
                this.ctx.scale(this.scale, this.scale);
                
                // Draw background
                const gradient = this.ctx.createLinearGradient(0, 0, 0, CONFIG.VIRTUAL_HEIGHT);
                gradient.addColorStop(0, '#1a1a2e');
                gradient.addColorStop(1, '#0f1419');
                this.ctx.fillStyle = gradient;
                this.ctx.fillRect(0, 0, CONFIG.VIRTUAL_WIDTH, CONFIG.VIRTUAL_HEIGHT);
                
                // Draw walls
                this.levelData.walls.forEach(wall => {
                    this.ctx.strokeStyle = wall.color;
                    this.ctx.lineWidth = wall.width;
                    this.ctx.lineCap = 'round';
                    this.ctx.beginPath();
                    this.ctx.moveTo(wall.x1, wall.y1);
                    this.ctx.lineTo(wall.x2, wall.y2);
                    this.ctx.stroke();
                });
                
                // Draw bumpers
                this.levelData.bumpers.forEach(bumper => {
                    const gradient = this.ctx.createRadialGradient(
                        bumper.x - 5, bumper.y - 5, 0,
                        bumper.x, bumper.y, bumper.radius
                    );
                    gradient.addColorStop(0, '#ffffff');
                    gradient.addColorStop(0.3, '#ff4444');
                    gradient.addColorStop(1, '#aa0000');
                    
                    this.ctx.fillStyle = gradient;
                    this.ctx.beginPath();
                    this.ctx.arc(bumper.x, bumper.y, bumper.radius, 0, Math.PI * 2);
                    this.ctx.fill();
                    
                    this.ctx.strokeStyle = '#ffffff';
                    this.ctx.lineWidth = 2;
                    this.ctx.stroke();
                });
                
                // Draw other objects (simplified versions)
                this.levelData.spinners.forEach(spinner => {
                    this.ctx.fillStyle = '#4444ff';
                    this.ctx.fillRect(
                        spinner.x - spinner.width/2,
                        spinner.y - spinner.height/2,
                        spinner.width,
                        spinner.height
                    );
                });
                
                this.levelData.dropTargets.forEach(target => {
                    this.ctx.fillStyle = '#ff8800';
                    this.ctx.fillRect(
                        target.x - target.width/2,
                        target.y - target.height/2,
                        target.width,
                        target.height
                    );
                });
                
                // Draw flippers
                this.levelData.flippers.forEach(flipper => {
                    this.ctx.fillStyle = this.leftFlipperActive && flipper.isLeft || 
                                      this.rightFlipperActive && !flipper.isLeft ? 
                                      '#ff4444' : '#ff6666';
                    
                    const length = CONFIG.FLIPPER_LENGTH;
                    const width = CONFIG.FLIPPER_WIDTH;
                    const angle = flipper.isLeft ? Math.PI / 8 : -Math.PI / 8;
                    
                    this.ctx.save();
                    this.ctx.translate(flipper.x, flipper.y);
                    this.ctx.rotate(angle);
                    
                    this.ctx.fillRect(-width/2, 0, width, length);
                    
                    this.ctx.restore();
                    
                    this.ctx.fillStyle = '#ffffff';
                    this.ctx.beginPath();
                    this.ctx.arc(flipper.x, flipper.y, 5, 0, Math.PI * 2);
                    this.ctx.fill();
                });
                
                // Draw ball
                const ballGradient = this.ctx.createRadialGradient(
                    this.ball.x - 3, this.ball.y - 3, 0,
                    this.ball.x, this.ball.y, this.ball.radius
                );
                ballGradient.addColorStop(0, '#ffffff');
                ballGradient.addColorStop(0.3, '#ffff80');
                ballGradient.addColorStop(1, '#ffcc00');
                
                this.ctx.fillStyle = ballGradient;
                this.ctx.beginPath();
                this.ctx.arc(this.ball.x, this.ball.y, this.ball.radius, 0, Math.PI * 2);
                this.ctx.fill();
                
                this.ctx.strokeStyle = '#ffffff';
                this.ctx.lineWidth = 1;
                this.ctx.stroke();
                
                this.ctx.restore();
                
                // Draw controls info
                this.ctx.fillStyle = '#00ff00';
                this.ctx.font = '14px Courier New';
                this.ctx.fillText('Controls: A/← = Left Flipper, D/→ = Right Flipper', 10, 30);
            }
            
            gameLoop() {
                if (!this.running) return;
                
                this.update();
                this.draw();
                
                requestAnimationFrame(() => this.gameLoop());
            }
        }
        
        // Initialize editor when page loads
        window.addEventListener('load', () => {
            new LevelEditor();
        });
    </script>
</body>
</html>
